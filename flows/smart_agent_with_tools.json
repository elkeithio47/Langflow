{
	"id": "4f6abffe-339b-48bd-af64-ba5969d897f5",
	"data": {
		"nodes": [
			{
				"id": "ToolCallingAgent-tcOHY",
				"type": "genericNode",
				"position": {
					"x": 1360.6137347060893,
					"y": 257.118711211211
				},
				"data": {
					"type": "ToolCallingAgent",
					"node": {
						"template": {
							"_type": "Component",
							"chat_history": {
								"trace_as_metadata": true,
								"list": true,
								"trace_as_input": true,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "chat_history",
								"value": "",
								"display_name": "Chat History",
								"advanced": true,
								"input_types": [
									"Data"
								],
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "other",
								"_input_type": "DataInput"
							},
							"llm": {
								"trace_as_metadata": true,
								"list": false,
								"required": true,
								"placeholder": "",
								"show": true,
								"name": "llm",
								"value": "",
								"display_name": "Language Model",
								"advanced": false,
								"input_types": [
									"LanguageModel"
								],
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "other",
								"_input_type": "HandleInput"
							},
							"tools": {
								"trace_as_metadata": true,
								"list": true,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "tools",
								"value": "",
								"display_name": "Tools",
								"advanced": false,
								"input_types": [
									"Tool",
									"BaseTool",
									"StructuredTool"
								],
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "other",
								"_input_type": "HandleInput"
							},
							"code": {
								"type": "code",
								"required": true,
								"placeholder": "",
								"list": false,
								"show": true,
								"multiline": true,
								"value": "from langchain.agents import create_tool_calling_agent\nfrom langchain_core.prompts import ChatPromptTemplate, HumanMessagePromptTemplate, PromptTemplate\n\nfrom langflow.base.agents.agent import LCToolsAgentComponent\nfrom langflow.inputs import MultilineInput\nfrom langflow.inputs.inputs import DataInput, HandleInput\nfrom langflow.schema import Data\n\n\nclass ToolCallingAgentComponent(LCToolsAgentComponent):\n    display_name: str = \"Tool Calling Agent\"\n    description: str = \"Agent that uses tools\"\n    icon = \"LangChain\"\n    beta = True\n    name = \"ToolCallingAgent\"\n\n    inputs = [\n        *LCToolsAgentComponent._base_inputs,\n        HandleInput(name=\"llm\", display_name=\"Language Model\", input_types=[\"LanguageModel\"], required=True),\n        MultilineInput(\n            name=\"system_prompt\",\n            display_name=\"System Prompt\",\n            info=\"System prompt for the agent.\",\n            value=\"You are a helpful assistant\",\n        ),\n        MultilineInput(\n            name=\"user_prompt\", display_name=\"Prompt\", info=\"This prompt must contain 'input' key.\", value=\"{input}\"\n        ),\n        DataInput(name=\"chat_history\", display_name=\"Chat History\", is_list=True, advanced=True),\n    ]\n\n    def get_chat_history_data(self) -> list[Data] | None:\n        return self.chat_history\n\n    def create_agent_runnable(self):\n        if \"input\" not in self.user_prompt:\n            msg = \"Prompt must contain 'input' key.\"\n            raise ValueError(msg)\n        messages = [\n            (\"system\", self.system_prompt),\n            (\"placeholder\", \"{chat_history}\"),\n            HumanMessagePromptTemplate(prompt=PromptTemplate(input_variables=[\"input\"], template=self.user_prompt)),\n            (\"placeholder\", \"{agent_scratchpad}\"),\n        ]\n        prompt = ChatPromptTemplate.from_messages(messages)\n        return create_tool_calling_agent(self.llm, self.tools, prompt)\n",
								"fileTypes": [],
								"file_path": "",
								"password": false,
								"name": "code",
								"advanced": true,
								"dynamic": true,
								"info": "",
								"load_from_db": false,
								"title_case": false
							},
							"handle_parsing_errors": {
								"trace_as_metadata": true,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "handle_parsing_errors",
								"value": true,
								"display_name": "Handle Parse Errors",
								"advanced": true,
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "bool",
								"_input_type": "BoolInput"
							},
							"input_value": {
								"trace_as_input": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "input_value",
								"value": "",
								"display_name": "Input",
								"advanced": false,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "str",
								"_input_type": "MessageTextInput"
							},
							"max_iterations": {
								"trace_as_metadata": true,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "max_iterations",
								"value": 15,
								"display_name": "Max Iterations",
								"advanced": true,
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "int",
								"_input_type": "IntInput"
							},
							"system_prompt": {
								"trace_as_input": true,
								"multiline": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "system_prompt",
								"value": "You are a helpful assistant",
								"display_name": "System Prompt",
								"advanced": false,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "System prompt for the agent.",
								"title_case": false,
								"type": "str",
								"_input_type": "MultilineInput"
							},
							"user_prompt": {
								"trace_as_input": true,
								"multiline": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "user_prompt",
								"value": "{input}",
								"display_name": "Prompt",
								"advanced": false,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "This prompt must contain 'input' key.",
								"title_case": false,
								"type": "str",
								"_input_type": "MultilineInput"
							},
							"verbose": {
								"trace_as_metadata": true,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "verbose",
								"value": true,
								"display_name": "Verbose",
								"advanced": true,
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "bool",
								"_input_type": "BoolInput"
							}
						},
						"description": "Agent that uses tools",
						"icon": "LangChain",
						"base_classes": [
							"AgentExecutor",
							"Message"
						],
						"display_name": "SMART Agent",
						"documentation": "",
						"custom_fields": {},
						"output_types": [],
						"pinned": false,
						"conditional_paths": [],
						"frozen": false,
						"outputs": [
							{
								"types": [
									"AgentExecutor"
								],
								"selected": "AgentExecutor",
								"name": "agent",
								"display_name": "Agent",
								"method": "build_agent",
								"value": "__UNDEFINED__",
								"cache": true,
								"required_inputs": [
									"tools"
								]
							},
							{
								"types": [
									"Message"
								],
								"selected": "Message",
								"name": "response",
								"display_name": "Response",
								"method": "message_response",
								"value": "__UNDEFINED__",
								"cache": true,
								"required_inputs": []
							}
						],
						"field_order": [
							"input_value",
							"handle_parsing_errors",
							"verbose",
							"max_iterations",
							"tools",
							"llm",
							"system_prompt",
							"user_prompt",
							"chat_history"
						],
						"beta": true,
						"edited": false,
						"metadata": {},
						"lf_version": "1.0.19"
					},
					"id": "ToolCallingAgent-tcOHY"
				},
				"selected": false,
				"width": 384,
				"height": 599,
				"positionAbsolute": {
					"x": 1360.6137347060893,
					"y": 257.118711211211
				},
				"dragging": false
			},
			{
				"id": "ChatInput-H5nXu",
				"type": "genericNode",
				"position": {
					"x": -121.27517475233214,
					"y": 5.9604700103406149
				},
				"data": {
					"type": "ChatInput",
					"node": {
						"template": {
							"_type": "Component",
							"files": {
								"trace_as_metadata": true,
								"file_path": "",
								"fileTypes": [
									"txt",
									"md",
									"mdx",
									"csv",
									"json",
									"yaml",
									"yml",
									"xml",
									"html",
									"htm",
									"pdf",
									"docx",
									"py",
									"sh",
									"sql",
									"js",
									"ts",
									"tsx",
									"jpg",
									"jpeg",
									"png",
									"bmp",
									"image"
								],
								"list": true,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "files",
								"value": "",
								"display_name": "Files",
								"advanced": true,
								"dynamic": false,
								"info": "Files to be sent with the message.",
								"title_case": false,
								"type": "file",
								"_input_type": "FileInput"
							},
							"code": {
								"type": "code",
								"required": true,
								"placeholder": "",
								"list": false,
								"show": true,
								"multiline": true,
								"value": "from langflow.base.data.utils import IMG_FILE_TYPES, TEXT_FILE_TYPES\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.io import DropdownInput, FileInput, MessageTextInput, MultilineInput, Output\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import MESSAGE_SENDER_AI, MESSAGE_SENDER_NAME_USER, MESSAGE_SENDER_USER\n\n\nclass ChatInput(ChatComponent):\n    display_name = \"Chat Input\"\n    description = \"Get chat inputs from the Playground.\"\n    icon = \"ChatInput\"\n    name = \"ChatInput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            value=\"\",\n            info=\"Message to be passed as input.\",\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_USER,\n            info=\"Type of sender.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_USER,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        FileInput(\n            name=\"files\",\n            display_name=\"Files\",\n            file_types=TEXT_FILE_TYPES + IMG_FILE_TYPES,\n            info=\"Files to be sent with the message.\",\n            advanced=True,\n            is_list=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Message\", name=\"message\", method=\"message_response\"),\n    ]\n\n    def message_response(self) -> Message:\n        message = Message(\n            text=self.input_value,\n            sender=self.sender,\n            sender_name=self.sender_name,\n            session_id=self.session_id,\n            files=self.files,\n        )\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = self.store_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n",
								"fileTypes": [],
								"file_path": "",
								"password": false,
								"name": "code",
								"advanced": true,
								"dynamic": true,
								"info": "",
								"load_from_db": false,
								"title_case": false
							},
							"input_value": {
								"trace_as_input": true,
								"multiline": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "input_value",
								"value": "I want to know about Mbridge? what is this? what crypto currencies are being used?",
								"display_name": "Text",
								"advanced": false,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "Message to be passed as input.",
								"title_case": false,
								"type": "str",
								"_input_type": "MultilineInput"
							},
							"sender": {
								"trace_as_metadata": true,
								"options": [
									"Machine",
									"User"
								],
								"combobox": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "sender",
								"value": "User",
								"display_name": "Sender Type",
								"advanced": true,
								"dynamic": false,
								"info": "Type of sender.",
								"title_case": false,
								"type": "str",
								"_input_type": "DropdownInput"
							},
							"sender_name": {
								"trace_as_input": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "sender_name",
								"value": "User",
								"display_name": "Sender Name",
								"advanced": true,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "Name of the sender.",
								"title_case": false,
								"type": "str",
								"_input_type": "MessageTextInput"
							},
							"session_id": {
								"trace_as_input": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "session_id",
								"value": "",
								"display_name": "Session ID",
								"advanced": true,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
								"title_case": false,
								"type": "str",
								"_input_type": "MessageTextInput"
							},
							"should_store_message": {
								"trace_as_metadata": true,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "should_store_message",
								"value": true,
								"display_name": "Store Messages",
								"advanced": true,
								"dynamic": false,
								"info": "Store the message in the history.",
								"title_case": false,
								"type": "bool",
								"_input_type": "BoolInput"
							}
						},
						"description": "Get chat inputs from the Playground.",
						"icon": "ChatInput",
						"base_classes": [
							"Message"
						],
						"display_name": "Chat Input",
						"documentation": "",
						"custom_fields": {},
						"output_types": [],
						"pinned": false,
						"conditional_paths": [],
						"frozen": false,
						"outputs": [
							{
								"types": [
									"Message"
								],
								"selected": "Message",
								"name": "message",
								"display_name": "Message",
								"method": "message_response",
								"value": "__UNDEFINED__",
								"cache": true
							}
						],
						"field_order": [
							"input_value",
							"should_store_message",
							"sender",
							"sender_name",
							"session_id",
							"files"
						],
						"beta": false,
						"edited": false,
						"metadata": {},
						"lf_version": "1.0.19"
					},
					"id": "ChatInput-H5nXu"
				},
				"selected": false,
				"width": 384,
				"height": 290,
				"positionAbsolute": {
					"x": -121.27517475233214,
					"y": 5.9604700103406149
				},
				"dragging": false
			},
			{
				"id": "ChatOutput-y8tZy",
				"type": "genericNode",
				"position": {
					"x": 1973.1914130666328,
					"y": 187.15608963779506
				},
				"data": {
					"type": "ChatOutput",
					"node": {
						"template": {
							"_type": "Component",
							"code": {
								"type": "code",
								"required": true,
								"placeholder": "",
								"list": false,
								"show": true,
								"multiline": true,
								"value": "from langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.io import DropdownInput, MessageTextInput, Output\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import MESSAGE_SENDER_AI, MESSAGE_SENDER_NAME_AI, MESSAGE_SENDER_USER\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    icon = \"ChatOutput\"\n    name = \"ChatOutput\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Message to be passed as output.\",\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Message\", name=\"message\", method=\"message_response\"),\n    ]\n\n    def message_response(self) -> Message:\n        message = Message(\n            text=self.input_value,\n            sender=self.sender,\n            sender_name=self.sender_name,\n            session_id=self.session_id,\n        )\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = self.store_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n",
								"fileTypes": [],
								"file_path": "",
								"password": false,
								"name": "code",
								"advanced": true,
								"dynamic": true,
								"info": "",
								"load_from_db": false,
								"title_case": false
							},
							"data_template": {
								"trace_as_input": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "data_template",
								"value": "{text}",
								"display_name": "Data Template",
								"advanced": true,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
								"title_case": false,
								"type": "str",
								"_input_type": "MessageTextInput"
							},
							"input_value": {
								"trace_as_input": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "input_value",
								"value": "",
								"display_name": "Text",
								"advanced": false,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "Message to be passed as output.",
								"title_case": false,
								"type": "str",
								"_input_type": "MessageTextInput"
							},
							"sender": {
								"trace_as_metadata": true,
								"options": [
									"Machine",
									"User"
								],
								"combobox": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "sender",
								"value": "Machine",
								"display_name": "Sender Type",
								"advanced": true,
								"dynamic": false,
								"info": "Type of sender.",
								"title_case": false,
								"type": "str",
								"_input_type": "DropdownInput"
							},
							"sender_name": {
								"trace_as_input": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "sender_name",
								"value": "AI",
								"display_name": "Sender Name",
								"advanced": true,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "Name of the sender.",
								"title_case": false,
								"type": "str",
								"_input_type": "MessageTextInput"
							},
							"session_id": {
								"trace_as_input": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "session_id",
								"value": "",
								"display_name": "Session ID",
								"advanced": true,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
								"title_case": false,
								"type": "str",
								"_input_type": "MessageTextInput"
							},
							"should_store_message": {
								"trace_as_metadata": true,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "should_store_message",
								"value": true,
								"display_name": "Store Messages",
								"advanced": true,
								"dynamic": false,
								"info": "Store the message in the history.",
								"title_case": false,
								"type": "bool",
								"_input_type": "BoolInput"
							}
						},
						"description": "Display a chat message in the Playground.",
						"icon": "ChatOutput",
						"base_classes": [
							"Message"
						],
						"display_name": "Chat Output",
						"documentation": "",
						"custom_fields": {},
						"output_types": [],
						"pinned": false,
						"conditional_paths": [],
						"frozen": false,
						"outputs": [
							{
								"types": [
									"Message"
								],
								"selected": "Message",
								"name": "message",
								"display_name": "Message",
								"method": "message_response",
								"value": "__UNDEFINED__",
								"cache": true
							}
						],
						"field_order": [
							"input_value",
							"should_store_message",
							"sender",
							"sender_name",
							"session_id",
							"data_template"
						],
						"beta": false,
						"edited": false,
						"metadata": {},
						"lf_version": "1.0.19"
					},
					"id": "ChatOutput-y8tZy"
				},
				"selected": false,
				"width": 384,
				"height": 290,
				"positionAbsolute": {
					"x": 1973.1914130666328,
					"y": 187.15608963779506
				},
				"dragging": false
			},
			{
				"id": "Prompt-G0PMC",
				"type": "genericNode",
				"position": {
					"x": 535.1652917130554,
					"y": 149.3741950142362
				},
				"data": {
					"type": "Prompt",
					"node": {
						"template": {
							"_type": "Component",
							"code": {
								"type": "code",
								"required": true,
								"placeholder": "",
								"list": false,
								"show": true,
								"multiline": true,
								"value": "from langflow.base.prompts.api_utils import process_prompt_template\nfrom langflow.custom import Component\nfrom langflow.inputs.inputs import DefaultPromptField\nfrom langflow.io import Output, PromptInput\nfrom langflow.schema.message import Message\nfrom langflow.template.utils import update_template_values\n\n\nclass PromptComponent(Component):\n    display_name: str = \"Prompt\"\n    description: str = \"Create a prompt template with dynamic variables.\"\n    icon = \"prompts\"\n    trace_type = \"prompt\"\n    name = \"Prompt\"\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt Message\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    async def build_prompt(\n        self,\n    ) -> Message:\n        prompt = await Message.from_template_and_variables(**self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def _update_template(self, frontend_node: dict):\n        prompt_template = frontend_node[\"template\"][\"template\"][\"value\"]\n        custom_fields = frontend_node[\"custom_fields\"]\n        frontend_node_template = frontend_node[\"template\"]\n        _ = process_prompt_template(\n            template=prompt_template,\n            name=\"template\",\n            custom_fields=custom_fields,\n            frontend_node_template=frontend_node_template,\n        )\n        return frontend_node\n\n    def post_code_processing(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"This function is called after the code validation is done.\"\"\"\n        frontend_node = super().post_code_processing(new_frontend_node, current_frontend_node)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        # Kept it duplicated for backwards compatibility\n        _ = process_prompt_template(\n            template=template,\n            name=\"template\",\n            custom_fields=frontend_node[\"custom_fields\"],\n            frontend_node_template=frontend_node[\"template\"],\n        )\n        # Now that template is updated, we need to grab any values that were set in the current_frontend_node\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_frontend_node[\"template\"])\n        return frontend_node\n\n    def _get_fallback_input(self, **kwargs):\n        return DefaultPromptField(**kwargs)\n",
								"fileTypes": [],
								"file_path": "",
								"password": false,
								"name": "code",
								"advanced": true,
								"dynamic": true,
								"info": "",
								"load_from_db": false,
								"title_case": false
							},
							"template": {
								"trace_as_input": true,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "template",
								"value": "You are an advanced AI agent specialized in performing deep financial research on cryptocurrencies. Your task is to provide comprehensive, insightful analysis using a variety of tools and data sources. Follow these instructions carefully:\n\n1. Review the conversation history:\n<conversation_history>\n{conversation_history}\n</conversation_history>\n\nCarefully analyze this history to understand the context of the current query and any previous information or insights provided.\n\n2. Process the user's query:\n<user_query>\n{input}\n</user_query>\n\n3. Research Methodology:\n   a. Determine which tools are most relevant to answer the query.\n   b. Use the tools in a logical sequence to gather comprehensive data.\n   c. Cross-reference information from multiple sources for accuracy.\n   d. Analyze quantitative and qualitative data to identify trends and patterns.\n   e. Consider short-term, mid-term, and long-term horizons in your analysis.\n   f. Look for interconnections between different trends and weak signals of emerging developments.\n\n4. Available Tools:\n   - Coinmarketcap Real-time Market Data Tool\n   - Google Serper Tool\n   - News Tool\n   - DuckDuckGo Internet Search Tool\n   - Yahoo Finance Crypto Tool\n   - Wikipedia Tool\n\nUse these tools extensively to gather and analyze data. Always sanitize the data using the Sanitization Tool before processing.\n\n5. Report Generation:\n   a. Synthesize the collected data into coherent insights.\n   b. Structure your report based on the level of detail required:\n      - Summary Report: High-level overview of key insights\n      - Detailed Report: In-depth analysis of each data point\n   c. Include relevant quantitative data, qualitative insights, and trend analysis.\n   d. Provide actionable insights and potential future scenarios.\n\n6. Output Format:\n   Present your final report within <report> tags. Structure it as follows:\n   <report>\n   <summary>\n   [Provide a concise summary of key findings]\n   </summary>\n   \n   <detailed_analysis>\n   [Present your in-depth analysis, broken down into relevant sections]\n   </detailed_analysis>\n   \n   <future_outlook>\n   [Discuss potential future scenarios and their implications]\n   </future_outlook>\n   \n   <actionable_insights>\n   [Provide concrete, actionable recommendations based on your analysis]\n   </actionable_insights>\n   </report>\n\n7. User Satisfaction Check:\n   After presenting your report, ask the user if they are satisfied or if they want you to explore deeper into a specific area of interest. Include this question within <follow_up> tags.\n\nRemember to maintain a professional, analytical tone throughout your response. Your goal is to provide deep, actionable insights that go beyond surface-level analysis. Always strive to connect dots across different data points and identify emerging trends or potential disruptions in the cryptocurrency space.",
								"display_name": "Template",
								"advanced": false,
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "prompt",
								"_input_type": "PromptInput"
							},
							"conversation_history": {
								"field_type": "str",
								"required": false,
								"placeholder": "",
								"list": false,
								"show": true,
								"multiline": true,
								"value": "",
								"fileTypes": [],
								"file_path": "",
								"name": "conversation_history",
								"display_name": "conversation_history",
								"advanced": false,
								"input_types": [
									"Message",
									"Text"
								],
								"dynamic": false,
								"info": "",
								"load_from_db": false,
								"title_case": false,
								"type": "str"
							},
							"input": {
								"field_type": "str",
								"required": false,
								"placeholder": "",
								"list": false,
								"show": true,
								"multiline": true,
								"value": "",
								"fileTypes": [],
								"file_path": "",
								"name": "input",
								"display_name": "input",
								"advanced": false,
								"input_types": [
									"Message",
									"Text"
								],
								"dynamic": false,
								"info": "",
								"load_from_db": false,
								"title_case": false,
								"type": "str"
							}
						},
						"description": "Create a prompt template with dynamic variables.",
						"icon": "prompts",
						"is_input": null,
						"is_output": null,
						"is_composition": null,
						"base_classes": [
							"Message"
						],
						"name": "",
						"display_name": "Prompt",
						"documentation": "",
						"custom_fields": {
							"template": [
								"conversation_history",
								"input"
							]
						},
						"output_types": [],
						"full_path": null,
						"pinned": false,
						"conditional_paths": [],
						"frozen": false,
						"outputs": [
							{
								"types": [
									"Message"
								],
								"selected": "Message",
								"name": "prompt",
								"hidden": null,
								"display_name": "Prompt Message",
								"method": "build_prompt",
								"value": "__UNDEFINED__",
								"cache": true,
								"required_inputs": null
							}
						],
						"field_order": [
							"template"
						],
						"beta": false,
						"error": null,
						"edited": false,
						"metadata": {},
						"lf_version": "1.0.19"
					},
					"id": "Prompt-G0PMC"
				},
				"selected": false,
				"width": 384,
				"height": 479,
				"positionAbsolute": {
					"x": 535.1652917130554,
					"y": 149.3741950142362
				},
				"dragging": false
			},
			{
				"id": "Memory-9bSSe",
				"type": "genericNode",
				"position": {
					"x": 39.93018008267154,
					"y": 522.0582104895686
				},
				"data": {
					"type": "Memory",
					"node": {
						"template": {
							"_type": "Component",
							"memory": {
								"trace_as_metadata": true,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "memory",
								"value": "",
								"display_name": "External Memory",
								"advanced": false,
								"input_types": [
									"BaseChatMessageHistory"
								],
								"dynamic": false,
								"info": "Retrieve messages from an external memory. If empty, it will use the Langflow tables.",
								"title_case": false,
								"type": "other",
								"_input_type": "HandleInput"
							},
							"code": {
								"type": "code",
								"required": true,
								"placeholder": "",
								"list": false,
								"show": true,
								"multiline": true,
								"value": "from langchain.memory import ConversationBufferMemory\n\nfrom langflow.custom import Component\nfrom langflow.field_typing import BaseChatMemory\nfrom langflow.helpers.data import data_to_text\nfrom langflow.inputs import HandleInput\nfrom langflow.io import DropdownInput, IntInput, MessageTextInput, MultilineInput, Output\nfrom langflow.memory import LCBuiltinChatMemory, get_messages\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import MESSAGE_SENDER_AI, MESSAGE_SENDER_USER\n\n\nclass MemoryComponent(Component):\n    display_name = \"Chat Memory\"\n    description = \"Retrieves stored chat messages from Langflow tables or an external memory.\"\n    icon = \"message-square-more\"\n    name = \"Memory\"\n\n    inputs = [\n        HandleInput(\n            name=\"memory\",\n            display_name=\"External Memory\",\n            input_types=[\"BaseChatMessageHistory\"],\n            info=\"Retrieve messages from an external memory. If empty, it will use the Langflow tables.\",\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER, \"Machine and User\"],\n            value=\"Machine and User\",\n            info=\"Filter by sender type.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Filter by sender name.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"n_messages\",\n            display_name=\"Number of Messages\",\n            value=100,\n            info=\"Number of messages to retrieve.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"order\",\n            display_name=\"Order\",\n            options=[\"Ascending\", \"Descending\"],\n            value=\"Ascending\",\n            info=\"Order of the messages.\",\n            advanced=True,\n        ),\n        MultilineInput(\n            name=\"template\",\n            display_name=\"Template\",\n            info=\"The template to use for formatting the data. \"\n            \"It can contain the keys {text}, {sender} or any other key in the message data.\",\n            value=\"{sender_name}: {text}\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Messages (Data)\", name=\"messages\", method=\"retrieve_messages\"),\n        Output(display_name=\"Messages (Text)\", name=\"messages_text\", method=\"retrieve_messages_as_text\"),\n        Output(display_name=\"Memory\", name=\"lc_memory\", method=\"build_lc_memory\"),\n    ]\n\n    def retrieve_messages(self) -> Data:\n        sender = self.sender\n        sender_name = self.sender_name\n        session_id = self.session_id\n        n_messages = self.n_messages\n        order = \"DESC\" if self.order == \"Descending\" else \"ASC\"\n\n        if sender == \"Machine and User\":\n            sender = None\n\n        if self.memory:\n            # override session_id\n            self.memory.session_id = session_id\n\n            stored = self.memory.messages\n            # langchain memories are supposed to return messages in ascending order\n            if order == \"DESC\":\n                stored = stored[::-1]\n            if n_messages:\n                stored = stored[:n_messages]\n            stored = [Message.from_lc_message(m) for m in stored]\n            if sender:\n                expected_type = MESSAGE_SENDER_AI if sender == MESSAGE_SENDER_AI else MESSAGE_SENDER_USER\n                stored = [m for m in stored if m.type == expected_type]\n        else:\n            stored = get_messages(\n                sender=sender,\n                sender_name=sender_name,\n                session_id=session_id,\n                limit=n_messages,\n                order=order,\n            )\n        self.status = stored\n        return stored\n\n    def retrieve_messages_as_text(self) -> Message:\n        stored_text = data_to_text(self.template, self.retrieve_messages())\n        self.status = stored_text\n        return Message(text=stored_text)\n\n    def build_lc_memory(self) -> BaseChatMemory:\n        chat_memory = self.memory or LCBuiltinChatMemory(flow_id=self.flow_id, session_id=self.session_id)\n        return ConversationBufferMemory(chat_memory=chat_memory)\n",
								"fileTypes": [],
								"file_path": "",
								"password": false,
								"name": "code",
								"advanced": true,
								"dynamic": true,
								"info": "",
								"load_from_db": false,
								"title_case": false
							},
							"n_messages": {
								"trace_as_metadata": true,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "n_messages",
								"value": 100,
								"display_name": "Number of Messages",
								"advanced": true,
								"dynamic": false,
								"info": "Number of messages to retrieve.",
								"title_case": false,
								"type": "int",
								"_input_type": "IntInput"
							},
							"order": {
								"trace_as_metadata": true,
								"options": [
									"Ascending",
									"Descending"
								],
								"combobox": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "order",
								"value": "Ascending",
								"display_name": "Order",
								"advanced": true,
								"dynamic": false,
								"info": "Order of the messages.",
								"title_case": false,
								"type": "str",
								"_input_type": "DropdownInput"
							},
							"sender": {
								"trace_as_metadata": true,
								"options": [
									"Machine",
									"User",
									"Machine and User"
								],
								"combobox": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "sender",
								"value": "Machine and User",
								"display_name": "Sender Type",
								"advanced": true,
								"dynamic": false,
								"info": "Filter by sender type.",
								"title_case": false,
								"type": "str",
								"_input_type": "DropdownInput"
							},
							"sender_name": {
								"trace_as_input": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "sender_name",
								"value": "",
								"display_name": "Sender Name",
								"advanced": true,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "Filter by sender name.",
								"title_case": false,
								"type": "str",
								"_input_type": "MessageTextInput"
							},
							"session_id": {
								"trace_as_input": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "session_id",
								"value": "",
								"display_name": "Session ID",
								"advanced": true,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
								"title_case": false,
								"type": "str",
								"_input_type": "MessageTextInput"
							},
							"template": {
								"trace_as_input": true,
								"multiline": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "template",
								"value": "{sender_name}: {text}",
								"display_name": "Template",
								"advanced": true,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "The template to use for formatting the data. It can contain the keys {text}, {sender} or any other key in the message data.",
								"title_case": false,
								"type": "str",
								"_input_type": "MultilineInput"
							}
						},
						"description": "Retrieves stored chat messages from Langflow tables or an external memory.",
						"icon": "message-square-more",
						"base_classes": [
							"BaseChatMemory",
							"Data",
							"Message"
						],
						"display_name": "Chat Memory",
						"documentation": "",
						"custom_fields": {},
						"output_types": [],
						"pinned": false,
						"conditional_paths": [],
						"frozen": false,
						"outputs": [
							{
								"types": [
									"Data"
								],
								"selected": "Data",
								"name": "messages",
								"display_name": "Messages (Data)",
								"method": "retrieve_messages",
								"value": "__UNDEFINED__",
								"cache": true
							},
							{
								"types": [
									"Message"
								],
								"selected": "Message",
								"name": "messages_text",
								"display_name": "Messages (Text)",
								"method": "retrieve_messages_as_text",
								"value": "__UNDEFINED__",
								"cache": true
							},
							{
								"types": [
									"BaseChatMemory"
								],
								"selected": "BaseChatMemory",
								"name": "lc_memory",
								"display_name": "Memory",
								"method": "build_lc_memory",
								"value": "__UNDEFINED__",
								"cache": true
							}
						],
						"field_order": [
							"memory",
							"sender",
							"sender_name",
							"n_messages",
							"session_id",
							"order",
							"template"
						],
						"beta": false,
						"edited": false,
						"metadata": {},
						"lf_version": "1.0.19"
					},
					"id": "Memory-9bSSe"
				},
				"selected": false,
				"width": 384,
				"height": 348,
				"positionAbsolute": {
					"x": 39.93018008267154,
					"y": 522.0582104895686
				},
				"dragging": false
			},
			{
				"id": "WikipediaAPI-chfQ8",
				"type": "genericNode",
				"position": {
					"x": -219.901711388825,
					"y": 1520.8921316577219
				},
				"data": {
					"type": "WikipediaAPI",
					"node": {
						"template": {
							"_type": "Component",
							"code": {
								"type": "code",
								"required": true,
								"placeholder": "",
								"list": false,
								"show": true,
								"multiline": true,
								"value": "from typing import cast\n\nfrom langchain_community.tools import WikipediaQueryRun\nfrom langchain_community.utilities.wikipedia import WikipediaAPIWrapper\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import BoolInput, IntInput, MessageTextInput, MultilineInput\nfrom langflow.schema import Data\n\n\nclass WikipediaAPIComponent(LCToolComponent):\n    display_name = \"Wikipedia API\"\n    description = \"Call Wikipedia API.\"\n    name = \"WikipediaAPI\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input\",\n        ),\n        MessageTextInput(name=\"lang\", display_name=\"Language\", value=\"en\"),\n        IntInput(name=\"k\", display_name=\"Number of results\", value=4, required=True),\n        BoolInput(name=\"load_all_available_meta\", display_name=\"Load all available meta\", value=False, advanced=True),\n        IntInput(\n            name=\"doc_content_chars_max\", display_name=\"Document content characters max\", value=4000, advanced=True\n        ),\n    ]\n\n    def run_model(self) -> list[Data]:\n        wrapper = self._build_wrapper()\n        docs = wrapper.load(self.input_value)\n        data = [Data.from_document(doc) for doc in docs]\n        self.status = data\n        return data\n\n    def build_tool(self) -> Tool:\n        wrapper = self._build_wrapper()\n        return cast(Tool, WikipediaQueryRun(api_wrapper=wrapper))\n\n    def _build_wrapper(self) -> WikipediaAPIWrapper:\n        return WikipediaAPIWrapper(\n            top_k_results=self.k,\n            lang=self.lang,\n            load_all_available_meta=self.load_all_available_meta,\n            doc_content_chars_max=self.doc_content_chars_max,\n        )\n",
								"fileTypes": [],
								"file_path": "",
								"password": false,
								"name": "code",
								"advanced": true,
								"dynamic": true,
								"info": "",
								"load_from_db": false,
								"title_case": false
							},
							"doc_content_chars_max": {
								"trace_as_metadata": true,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "doc_content_chars_max",
								"value": 4000,
								"display_name": "Document content characters max",
								"advanced": true,
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "int",
								"_input_type": "IntInput"
							},
							"input_value": {
								"trace_as_input": true,
								"multiline": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "input_value",
								"value": "",
								"display_name": "Input",
								"advanced": false,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "str",
								"_input_type": "MultilineInput"
							},
							"k": {
								"trace_as_metadata": true,
								"list": false,
								"required": true,
								"placeholder": "",
								"show": true,
								"name": "k",
								"value": 4,
								"display_name": "Number of results",
								"advanced": false,
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "int",
								"_input_type": "IntInput"
							},
							"lang": {
								"trace_as_input": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "lang",
								"value": "en",
								"display_name": "Language",
								"advanced": false,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "str",
								"_input_type": "MessageTextInput"
							},
							"load_all_available_meta": {
								"trace_as_metadata": true,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "load_all_available_meta",
								"value": false,
								"display_name": "Load all available meta",
								"advanced": true,
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "bool",
								"_input_type": "BoolInput"
							}
						},
						"description": "Call Wikipedia API.",
						"base_classes": [
							"Data",
							"Tool"
						],
						"display_name": "Wikipedia API",
						"documentation": "",
						"custom_fields": {},
						"output_types": [],
						"pinned": false,
						"conditional_paths": [],
						"frozen": false,
						"outputs": [
							{
								"types": [
									"Data"
								],
								"selected": "Data",
								"name": "api_run_model",
								"display_name": "Data",
								"method": "run_model",
								"value": "__UNDEFINED__",
								"cache": true,
								"required_inputs": [
									"doc_content_chars_max",
									"input_value",
									"k",
									"lang",
									"load_all_available_meta"
								],
								"hidden": true
							},
							{
								"types": [
									"Tool"
								],
								"selected": "Tool",
								"name": "api_build_tool",
								"display_name": "Tool",
								"method": "build_tool",
								"value": "__UNDEFINED__",
								"cache": true,
								"required_inputs": [
									"doc_content_chars_max",
									"input_value",
									"k",
									"lang",
									"load_all_available_meta"
								]
							}
						],
						"field_order": [
							"input_value",
							"lang",
							"k",
							"load_all_available_meta",
							"doc_content_chars_max"
						],
						"beta": false,
						"edited": false,
						"metadata": {},
						"lf_version": "1.0.19"
					},
					"id": "WikipediaAPI-chfQ8"
				},
				"selected": false,
				"width": 384,
				"height": 463,
				"positionAbsolute": {
					"x": -219.901711388825,
					"y": 1520.8921316577219
				},
				"dragging": false
			},
			{
				"id": "WikipediaAPI-otxuG",
				"type": "genericNode",
				"position": {
					"x": -623.7634416676201,
					"y": 1523.7748887573892
				},
				"data": {
					"type": "CoinMarketCapAPI",
					"node": {
						"template": {
							"_type": "Component",
							"api_key": {
								"load_from_db": false,
								"required": true,
								"placeholder": "",
								"show": true,
								"name": "api_key",
								"value": "",
								"display_name": "CoinMarketCap API Key",
								"advanced": false,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "",
								"title_case": false,
								"password": true,
								"type": "str",
								"_input_type": "SecretStrInput"
							},
							"code": {
								"type": "code",
								"required": true,
								"placeholder": "",
								"list": false,
								"show": true,
								"multiline": true,
								"value": "from typing import Any\r\nfrom langchain.tools import StructuredTool\r\nfrom pydantic import BaseModel, Field\r\nfrom langflow.base.langchain_utilities.model import LCToolComponent\r\nfrom langflow.field_typing import Tool\r\nfrom langflow.inputs import DictInput, IntInput, MultilineInput, SecretStrInput\r\nfrom langflow.schema import Data\r\nimport requests\r\n\r\nclass CoinMarketCapAPIComponent(LCToolComponent):\r\n    display_name: str = \"CoinMarketCap API\"\r\n    description: str = \"Retrieve latest cryptocurrency data from CoinMarketCap.\"\r\n    name = \"CoinMarketCapAPI\"\r\n    documentation: str = \"https://coinmarketcap.com/api/documentation/v1/\"\r\n\r\n    class CoinMarketCapAPIWrapper:\r\n        \"\"\"Wrapper class to call CoinMarketCap API and retrieve cryptocurrency data.\"\"\"\r\n        def __init__(self, api_key: str):\r\n            self.api_key = api_key\r\n            self.url = \"https://pro-api.coinmarketcap.com/v1/cryptocurrency/listings/latest\"\r\n            self.headers = {\r\n                \"Accepts\": \"application/json\",\r\n                \"X-CMC_PRO_API_KEY\": self.api_key,\r\n            }\r\n    \r\n        def get_cryptocurrency_data(self, start: int = 1, limit: int = 10) -> list[dict[str, Any]]:\r\n            parameters = {\"start\": start, \"limit\": limit, \"convert\": \"USD\"}\r\n            response = requests.get(self.url, headers=self.headers, params=parameters)\r\n            data = response.json()\r\n    \r\n            if response.status_code != 200:\r\n                raise Exception(f\"Error {response.status_code}: {data.get('status', {}).get('error_message', 'Unknown error')}\")\r\n    \r\n            return data[\"data\"]\r\n    \r\n    # Define the inputs needed for this component\r\n    inputs = [\r\n        SecretStrInput(name=\"api_key\", display_name=\"CoinMarketCap API Key\", required=True),\r\n        IntInput(name=\"start\", display_name=\"Start\", value=1 , required=True),\r\n        IntInput(name=\"limit\", display_name=\"Limit\", value=10, required=True),\r\n    ]\r\n    \r\n        # Define the schema for the API tool arguments\r\n    class CoinMarketCapSchema(BaseModel):\r\n        start: int = Field(1, description=\"The rank from which to start the listing\")\r\n        limit: int = Field(10, description=\"The number of cryptocurrencies to retrieve\")\r\n    \r\n    \r\n    # Helper function to build the API wrapper\r\n    def _build_wrapper(self):\r\n        return self.CoinMarketCapAPIWrapper(api_key=self.api_key)\r\n\r\n    # Tool builder function\r\n    def build_tool(self) -> Tool:\r\n        wrapper = self._build_wrapper()\r\n\r\n        def get_crypto_data(\r\n            start: int = 1, limit: int = 10\r\n        ) -> list[dict[str, Any]]:\r\n            # Call the wrapper function to get cryptocurrency data\r\n            return wrapper.get_cryptocurrency_data(start=start, limit=limit)\r\n\r\n        # Return the StructuredTool\r\n        tool = StructuredTool.from_function(\r\n            name=\"coinmarketcap_api\",\r\n            description=\"Fetch latest cryptocurrency data from CoinMarketCap API\",\r\n            func=get_crypto_data,\r\n            args_schema=self.CoinMarketCapSchema,\r\n        )\r\n\r\n        self.status = f\"CoinMarketCap API Tool created with API Key.\"\r\n        return tool\r\n\r\n    # Run model function to trigger the API call\r\n    def run_model(self) -> list[Data]:\r\n        tool = self.build_tool()\r\n        results = tool.run(\r\n            {\r\n                \"start\": self.start,\r\n                \"limit\": self.limit,\r\n            }\r\n        )\r\n\r\n        data_list = [Data(data=result, text=f\"Name: {result['name']}, Price: {result['quote']['USD']['price']}\") for result in results]\r\n\r\n        self.status = data_list\r\n        return data_list    \r\n",
								"fileTypes": [],
								"file_path": "",
								"password": false,
								"name": "code",
								"advanced": true,
								"dynamic": true,
								"info": "",
								"load_from_db": false,
								"title_case": false
							},
							"limit": {
								"trace_as_metadata": true,
								"list": false,
								"required": true,
								"placeholder": "",
								"show": true,
								"name": "limit",
								"value": 10,
								"display_name": "Limit",
								"advanced": false,
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "int",
								"_input_type": "IntInput"
							},
							"start": {
								"trace_as_metadata": true,
								"list": false,
								"required": true,
								"placeholder": "",
								"show": true,
								"name": "start",
								"value": 1,
								"display_name": "Start",
								"advanced": false,
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "int",
								"_input_type": "IntInput"
							}
						},
						"description": "Retrieve latest cryptocurrency data from CoinMarketCap.",
						"base_classes": [
							"Data",
							"Tool"
						],
						"display_name": "CoinMarketCap API",
						"documentation": "https://coinmarketcap.com/api/documentation/v1/",
						"custom_fields": {},
						"output_types": [],
						"pinned": false,
						"conditional_paths": [],
						"frozen": false,
						"outputs": [
							{
								"types": [
									"Data"
								],
								"selected": "Data",
								"name": "api_run_model",
								"display_name": "Data",
								"method": "run_model",
								"value": "__UNDEFINED__",
								"cache": true,
								"required_inputs": [
									"api_key",
									"limit",
									"start"
								]
							},
							{
								"types": [
									"Tool"
								],
								"selected": "Tool",
								"name": "api_build_tool",
								"display_name": "Tool",
								"method": "build_tool",
								"value": "__UNDEFINED__",
								"cache": true,
								"required_inputs": [
									"api_key",
									"limit",
									"start"
								]
							}
						],
						"field_order": [
							"api_key",
							"start",
							"limit"
						],
						"beta": false,
						"edited": true,
						"metadata": {},
						"lf_version": "1.0.19"
					},
					"id": "WikipediaAPI-otxuG"
				},
				"selected": false,
				"width": 384,
				"height": 519,
				"positionAbsolute": {
					"x": -623.7634416676201,
					"y": 1523.7748887573892
				},
				"dragging": false
			},
			{
				"id": "DuckDuckGoSearch-5zWhQ",
				"type": "genericNode",
				"position": {
					"x": -1021.7438432465718,
					"y": 1525.8547690494755
				},
				"data": {
					"type": "DuckDuckGoSearch",
					"node": {
						"template": {
							"_type": "Component",
							"code": {
								"type": "code",
								"required": true,
								"placeholder": "",
								"list": false,
								"show": true,
								"multiline": true,
								"value": "from typing import Any\n\nfrom langchain.tools import StructuredTool\nfrom langchain_community.tools import DuckDuckGoSearchRun\nfrom pydantic import BaseModel, Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.field_typing import Tool\nfrom langflow.inputs import IntInput, MessageTextInput\nfrom langflow.schema import Data\n\n\nclass DuckDuckGoSearchComponent(LCToolComponent):\n    display_name: str = \"DuckDuckGo Search\"\n    description: str = \"Perform web searches using the DuckDuckGo search engine with result limiting\"\n    name = \"DuckDuckGoSearch\"\n    documentation: str = \"https://python.langchain.com/docs/integrations/tools/ddg\"\n    icon: str = \"DuckDuckGo\"\n    inputs = [\n        MessageTextInput(\n            name=\"input_value\",\n            display_name=\"Search Query\",\n            required=True,\n        ),\n        IntInput(name=\"max_results\", display_name=\"Max Results\", value=5, advanced=True),\n        IntInput(name=\"max_snippet_length\", display_name=\"Max Snippet Length\", value=100, advanced=True),\n    ]\n\n    class DuckDuckGoSearchSchema(BaseModel):\n        query: str = Field(..., description=\"The search query\")\n        max_results: int = Field(5, description=\"Maximum number of results to return\")\n        max_snippet_length: int = Field(100, description=\"Maximum length of each result snippet\")\n\n    def _build_wrapper(self):\n        return DuckDuckGoSearchRun()\n\n    def build_tool(self) -> Tool:\n        wrapper = self._build_wrapper()\n\n        def search_func(query: str, max_results: int = 5, max_snippet_length: int = 100) -> list[dict[str, Any]]:\n            full_results = wrapper.run(f\"{query} (site:*)\")\n            result_list = full_results.split(\"\\n\")[:max_results]\n            limited_results = []\n            for result in result_list:\n                limited_result = {\n                    \"snippet\": result[:max_snippet_length],\n                }\n                limited_results.append(limited_result)\n            return limited_results\n\n        tool = StructuredTool.from_function(\n            name=\"duckduckgo_search\",\n            description=\"Search for recent results using DuckDuckGo with result limiting\",\n            func=search_func,\n            args_schema=self.DuckDuckGoSearchSchema,\n        )\n        self.status = \"DuckDuckGo Search Tool created\"\n        return tool\n\n    def run_model(self) -> list[Data]:\n        tool = self.build_tool()\n        results = tool.run(\n            {\n                \"query\": self.input_value,\n                \"max_results\": self.max_results,\n                \"max_snippet_length\": self.max_snippet_length,\n            }\n        )\n        data_list = [Data(data=result, text=result.get(\"snippet\", \"\")) for result in results]\n        self.status = data_list\n        return data_list\n",
								"fileTypes": [],
								"file_path": "",
								"password": false,
								"name": "code",
								"advanced": true,
								"dynamic": true,
								"info": "",
								"load_from_db": false,
								"title_case": false
							},
							"input_value": {
								"trace_as_input": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": true,
								"placeholder": "",
								"show": true,
								"name": "input_value",
								"value": "cryptocurrency",
								"display_name": "Search Query",
								"advanced": false,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "str",
								"_input_type": "MessageTextInput"
							},
							"max_results": {
								"trace_as_metadata": true,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "max_results",
								"value": 5,
								"display_name": "Max Results",
								"advanced": true,
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "int",
								"_input_type": "IntInput"
							},
							"max_snippet_length": {
								"trace_as_metadata": true,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "max_snippet_length",
								"value": 100,
								"display_name": "Max Snippet Length",
								"advanced": true,
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "int",
								"_input_type": "IntInput"
							}
						},
						"description": "Perform web searches using the DuckDuckGo search engine with result limiting",
						"icon": "DuckDuckGo",
						"base_classes": [
							"Data",
							"Tool"
						],
						"display_name": "DuckDuckGo Search",
						"documentation": "https://python.langchain.com/docs/integrations/tools/ddg",
						"custom_fields": {},
						"output_types": [],
						"pinned": false,
						"conditional_paths": [],
						"frozen": false,
						"outputs": [
							{
								"types": [
									"Data"
								],
								"selected": "Data",
								"name": "api_run_model",
								"display_name": "Data",
								"method": "run_model",
								"value": "__UNDEFINED__",
								"cache": true,
								"required_inputs": [
									"input_value",
									"max_results",
									"max_snippet_length"
								],
								"hidden": true
							},
							{
								"types": [
									"Tool"
								],
								"selected": "Tool",
								"name": "api_build_tool",
								"display_name": "Tool",
								"method": "build_tool",
								"value": "__UNDEFINED__",
								"cache": true,
								"required_inputs": [
									"input_value",
									"max_results",
									"max_snippet_length"
								]
							}
						],
						"field_order": [
							"input_value",
							"max_results",
							"max_snippet_length"
						],
						"beta": false,
						"edited": false,
						"metadata": {},
						"lf_version": "1.0.19"
					},
					"id": "DuckDuckGoSearch-5zWhQ"
				},
				"selected": false,
				"width": 384,
				"height": 306,
				"positionAbsolute": {
					"x": -1021.7438432465718,
					"y": 1525.8547690494755
				},
				"dragging": false
			},
			{
				"id": "CoinMarketCapAPI-6u9M0",
				"type": "genericNode",
				"position": {
					"x": -1423.9157558683515,
					"y": 1522.6992360602627
				},
				"data": {
					"type": "NewsAPI",
					"node": {
						"template": {
							"_type": "Component",
							"api_key": {
								"load_from_db": false,
								"required": true,
								"placeholder": "",
								"show": true,
								"name": "api_key",
								"value": "",
								"display_name": "News API Key",
								"advanced": true,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "",
								"title_case": false,
								"password": true,
								"type": "str",
								"_input_type": "SecretStrInput"
							},
							"code": {
								"type": "code",
								"required": true,
								"placeholder": "",
								"list": false,
								"show": true,
								"multiline": true,
								"value": "from typing import Any\r\n\r\nfrom langchain.tools import StructuredTool\r\nfrom pydantic import BaseModel, Field\r\nfrom langflow.base.langchain_utilities.model import LCToolComponent\r\nfrom langflow.field_typing import Tool\r\nfrom langflow.inputs import IntInput, MessageTextInput, SecretStrInput\r\nfrom langflow.schema import Data\r\nimport requests\r\n\r\n\r\n# Define the component class for News API\r\nclass NewsAPIComponent(LCToolComponent):\r\n    display_name: str = \"News API\"\r\n    description: str = \"Retrieve the latest news articles using the News API.\"\r\n    name = \"NewsAPI\"\r\n    documentation: str = \"https://newsapi.org/docs/endpoints/everything\"\r\n\r\n    # Define the inputs needed for this component\r\n    inputs = [\r\n        SecretStrInput(name=\"api_key\", display_name=\"News API Key\", required=True),\r\n        MessageTextInput(name=\"query\", display_name=\"Search Query\", required=True),\r\n        IntInput(name=\"page_size\", display_name=\"Number of Results\", value=10, required=False),\r\n        MessageTextInput(name=\"language\", display_name=\"Language\", value=\"en\", required=False),\r\n        MessageTextInput(name=\"sort_by\", display_name=\"Sort By\", value=\"publishedAt\", required=False),\r\n    ]\r\n\r\n    # Define the schema for the API tool arguments\r\n    class NewsAPISchema(BaseModel):\r\n        api_key: str = Field(..., description=\"Your News API Key\")\r\n        query: str = Field(..., description=\"The search query to look for in articles\")\r\n        page_size: int = Field(10, description=\"Number of articles to return\")\r\n        language: str = Field(\"en\", description=\"The language of the articles (default is 'en')\")\r\n        sort_by: str = Field(\"publishedAt\", description=\"Sort by relevancy, popularity, or published date (default is 'publishedAt')\")\r\n\r\n    # Define the API Wrapper for News API\r\n    class NewsAPIWrapper:\r\n        def __init__(self, api_key: str):\r\n            self.api_key = api_key\r\n            self.url = \"https://newsapi.org/v2/everything\"\r\n            self.headers = {\r\n                \"Authorization\": f\"Bearer {self.api_key}\",\r\n            }\r\n\r\n        def get_news(self, query: str, page_size: int = 10, language: str = \"en\", sort_by: str = \"publishedAt\") -> list[dict[str, Any]]:\r\n            params = {\r\n                \"q\": query,\r\n                \"pageSize\": page_size,\r\n                \"language\": language,\r\n                \"sortBy\": sort_by,\r\n            }\r\n            response = requests.get(self.url, headers=self.headers, params=params)\r\n\r\n            if response.status_code == 401:\r\n                raise Exception(\"Error 401: Unauthorized. Please check your API key.\")\r\n            elif response.status_code != 200:\r\n                raise Exception(f\"Error {response.status_code}: {response.json().get('message', 'Unknown error')}\")\r\n\r\n            return response.json().get('articles', [])\r\n\r\n    # Build the API wrapper\r\n    def _build_wrapper(self, api_key: str):\r\n        return self.NewsAPIWrapper(api_key=api_key)\r\n\r\n    # Tool builder function\r\n    def build_tool(self) -> Tool:\r\n        def get_news(api_key: str, query: str, page_size: int = 10, language: str = \"en\", sort_by: str = \"publishedAt\") -> list[dict[str, Any]]:\r\n            wrapper = self._build_wrapper(api_key=api_key)\r\n            return wrapper.get_news(query=query, page_size=page_size, language=language, sort_by=sort_by)\r\n\r\n        tool = StructuredTool.from_function(\r\n            name=\"news_api\",\r\n            description=\"Fetch the latest news articles using the News API\",\r\n            func=get_news,\r\n            args_schema=self.NewsAPISchema,\r\n        )\r\n\r\n        self.status = f\"News API Tool created successfully with API Key.\"\r\n        return tool\r\n\r\n    # Run model function to trigger the API call\r\n    def run_model(self) -> list[Data]:\r\n        tool = self.build_tool()\r\n        # The API key and other inputs are passed dynamically\r\n        results = tool.run(\r\n            {\r\n                \"api_key\": self.api_key,\r\n                \"query\": self.query,\r\n                \"page_size\": self.page_size,\r\n                \"language\": self.language,\r\n                \"sort_by\": self.sort_by,\r\n            }\r\n        )\r\n\r\n        # Format the results for output\r\n        data_list = [Data(data=result, text=f\"Title: {result['title']}, Description: {result['description']}, URL: {result['url']}\") for result in results]\r\n\r\n        self.status = data_list\r\n        return data_list\r\n",
								"fileTypes": [],
								"file_path": "",
								"password": false,
								"name": "code",
								"advanced": true,
								"dynamic": true,
								"info": "",
								"load_from_db": false,
								"title_case": false
							},
							"language": {
								"trace_as_input": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "language",
								"value": "en",
								"display_name": "Language",
								"advanced": false,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "str",
								"_input_type": "MessageTextInput"
							},
							"page_size": {
								"trace_as_metadata": true,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "page_size",
								"value": 10,
								"display_name": "Number of Results",
								"advanced": false,
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "int",
								"_input_type": "IntInput"
							},
							"query": {
								"trace_as_input": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": true,
								"placeholder": "",
								"show": true,
								"name": "query",
								"value": "cryptocurrency",
								"display_name": "Search Query",
								"advanced": false,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "str",
								"_input_type": "MessageTextInput"
							},
							"sort_by": {
								"trace_as_input": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "sort_by",
								"value": "publishedAt",
								"display_name": "Sort By",
								"advanced": false,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "str",
								"_input_type": "MessageTextInput"
							}
						},
						"description": "Retrieve the latest news articles using the News API.",
						"base_classes": [
							"Data",
							"Tool"
						],
						"display_name": "News API",
						"documentation": "https://newsapi.org/docs/endpoints/everything",
						"custom_fields": {},
						"output_types": [],
						"pinned": false,
						"conditional_paths": [],
						"frozen": false,
						"outputs": [
							{
								"types": [
									"Data"
								],
								"selected": "Data",
								"name": "api_run_model",
								"display_name": "Data",
								"method": "run_model",
								"value": "__UNDEFINED__",
								"cache": true,
								"required_inputs": [
									"api_key",
									"language",
									"page_size",
									"query",
									"sort_by"
								],
								"hidden": true
							},
							{
								"types": [
									"Tool"
								],
								"selected": "Tool",
								"name": "api_build_tool",
								"display_name": "Tool",
								"method": "build_tool",
								"value": "__UNDEFINED__",
								"cache": true,
								"required_inputs": [
									"api_key",
									"language",
									"page_size",
									"query",
									"sort_by"
								]
							}
						],
						"field_order": [
							"api_key",
							"query",
							"page_size",
							"language",
							"sort_by"
						],
						"beta": false,
						"edited": true,
						"metadata": {},
						"lf_version": "1.0.19"
					},
					"id": "CoinMarketCapAPI-6u9M0"
				},
				"selected": false,
				"width": 384,
				"height": 565,
				"positionAbsolute": {
					"x": -1423.9157558683515,
					"y": 1522.6992360602627
				},
				"dragging": false
			},
			{
				"id": "NewsAPI-gygRV",
				"type": "genericNode",
				"position": {
					"x": -1829.8812507747835,
					"y": 1528.9340590628806
				},
				"data": {
					"type": "GoogleSerpAPI",
					"node": {
						"template": {
							"_type": "Component",
							"api_key": {
								"load_from_db": false,
								"required": true,
								"placeholder": "",
								"show": true,
								"name": "api_key",
								"value": "",
								"display_name": "SerpApi API Key",
								"advanced": false,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "",
								"title_case": false,
								"password": true,
								"type": "str",
								"_input_type": "SecretStrInput"
							},
							"code": {
								"type": "code",
								"required": true,
								"placeholder": "",
								"list": false,
								"show": true,
								"multiline": true,
								"value": "from typing import Any\r\nfrom langchain.tools import StructuredTool\r\nfrom pydantic import BaseModel, Field\r\nfrom langflow.base.langchain_utilities.model import LCToolComponent\r\nfrom langflow.field_typing import Tool\r\nfrom langflow.inputs import IntInput, MessageTextInput, SecretStrInput\r\nfrom langflow.schema import Data\r\nimport requests\r\nimport logging\r\n\r\n# Configure logging\r\nlogging.basicConfig(level=logging.DEBUG)\r\n\r\n# Define the component class for SerpApi\r\nclass GoogleSerpAPIComponent(LCToolComponent):\r\n    display_name: str = \"Google Serp API\"\r\n    description: str = \"Retrieve search results using the Google Serp API.\"\r\n    name = \"GoogleSerpAPI\"\r\n    documentation: str = \"https://serpapi.com/docs/\"\r\n\r\n    # Define the inputs needed for this component\r\n    inputs = [\r\n        SecretStrInput(name=\"api_key\", display_name=\"SerpApi API Key\", required=True),\r\n        MessageTextInput(name=\"query\", display_name=\"Search Query\", required=True),\r\n        IntInput(name=\"num_results\", display_name=\"Number of Results\", value=10, required=True),\r\n        MessageTextInput(name=\"gl\", display_name=\"Geographical Location (gl)\", value=\"us\"),\r\n        MessageTextInput(name=\"hl\", display_name=\"Language (hl)\", value=\"en\"),\r\n    ]\r\n\r\n    # Define the schema for the API tool arguments\r\n    class GoogleSerpAPISchema(BaseModel):\r\n        api_key: str = Field(..., description=\"SerpApi API Key\")\r\n        query: str = Field(..., description=\"The search query string\")\r\n        num_results: int = Field(10, description=\"Number of search results to retrieve\")\r\n        gl: str = Field(\"us\", description=\"Geographical location (e.g., 'us' for United States)\")\r\n        hl: str = Field(\"en\", description=\"Language for the search (e.g., 'en' for English)\")\r\n\r\n    # Define the API Wrapper for SerpApi\r\n    class GoogleSerpAPIWrapper:\r\n        def __init__(self, api_key: str):\r\n            self.api_key = api_key\r\n            self.url = \"https://serpapi.com/search\"\r\n    \r\n        def get_search_results(self, query: str, num_results: int = 10, gl: str = \"us\", hl: str = \"en\") -> list[dict[str, Any]]:\r\n            params = {\r\n                \"q\": query,\r\n                \"num\": num_results,\r\n                \"gl\": gl,\r\n                \"hl\": hl,\r\n                \"engine\": \"google\",\r\n                \"api_key\": \"b9db80f260bf0ad145468f5445375fb55797ef18dac6d1a3c8a68ab917e1123b\" #self.api_key\"\"\r\n            }\r\n\r\n            # Print the API key being used\r\n            logging.debug(f\"API Key: {self.api_key}\")\r\n\r\n            # Log the URL and parameters being sent to SerpApi\r\n            logging.debug(f\"Request URL: {self.url}\")\r\n            logging.debug(f\"Request Params: {params}\")\r\n\r\n            response = requests.get(self.url, params=params)\r\n\r\n            # Log the response status and content\r\n            logging.debug(f\"Response Status Code: {response.status_code}\")\r\n            logging.debug(f\"Response Content: {response.text}\")\r\n\r\n            # Check for errors\r\n            if response.status_code == 403:\r\n                raise Exception(\"Error 403: Forbidden. Please check your API key or request quota.\")\r\n            elif response.status_code == 401:\r\n                raise Exception(\"Error 401: Invalid API key. Please verify your API key.\")\r\n            elif response.status_code != 200:\r\n                raise Exception(f\"Error {response.status_code}: {response.json().get('error', 'Unknown error')}\")\r\n\r\n            # Return the organic results from the response\r\n            return response.json().get('organic_results', [])\r\n\r\n    # Build the API wrapper\r\n    def _build_wrapper(self, api_key: str):\r\n        return self.GoogleSerpAPIWrapper(api_key=api_key)\r\n\r\n    # Tool builder function\r\n    def build_tool(self) -> Tool:\r\n        def get_search_results(api_key: str, query: str, num_results: int = 10, gl: str = \"us\", hl: str = \"en\") -> list[dict[str, Any]]:\r\n            wrapper = self._build_wrapper(api_key=api_key)\r\n            return wrapper.get_search_results(query=query, num_results=num_results, gl=gl, hl=hl)\r\n\r\n        tool = StructuredTool.from_function(\r\n            name=\"google_serp_api\",\r\n            description=\"Fetch search results using Google Serp API\",\r\n            func=get_search_results,\r\n            args_schema=self.GoogleSerpAPISchema,\r\n        )\r\n\r\n        self.status = \"Google Serp API Tool created successfully.\"\r\n        return tool\r\n\r\n    # Run model function to trigger the API call\r\n    def run_model(self) -> list[Data]:\r\n        tool = self.build_tool()\r\n        results = tool.run(\r\n            {\r\n                \"api_key\": self.api_key,\r\n                \"query\": self.query,\r\n                \"num_results\": self.num_results,\r\n                \"gl\": self.gl,\r\n                \"hl\": self.hl,\r\n            }\r\n        )\r\n\r\n        # Format the results for output\r\n        data_list = [Data(data=result, text=f\"Title: {result['title']}, Snippet: {result['snippet']}\") for result in results]\r\n\r\n        self.status = data_list\r\n        return data_list\r\n",
								"fileTypes": [],
								"file_path": "",
								"password": false,
								"name": "code",
								"advanced": true,
								"dynamic": true,
								"info": "",
								"load_from_db": false,
								"title_case": false
							},
							"gl": {
								"trace_as_input": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "gl",
								"value": "us",
								"display_name": "Geographical Location (gl)",
								"advanced": false,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "str",
								"_input_type": "MessageTextInput"
							},
							"hl": {
								"trace_as_input": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "hl",
								"value": "en",
								"display_name": "Language (hl)",
								"advanced": false,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "str",
								"_input_type": "MessageTextInput"
							},
							"num_results": {
								"trace_as_metadata": true,
								"list": false,
								"required": true,
								"placeholder": "",
								"show": true,
								"name": "num_results",
								"value": 4,
								"display_name": "Number of Results",
								"advanced": false,
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "int",
								"_input_type": "IntInput",
								"load_from_db": false
							},
							"query": {
								"trace_as_input": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": true,
								"placeholder": "",
								"show": true,
								"name": "query",
								"value": "cryptocurrency",
								"display_name": "Search Query",
								"advanced": false,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "str",
								"_input_type": "MessageTextInput"
							}
						},
						"description": "Retrieve search results using the Google Serp API.",
						"base_classes": [
							"Data",
							"Tool"
						],
						"display_name": "Google Serper API",
						"documentation": "https://serpapi.com/docs/",
						"custom_fields": {},
						"output_types": [],
						"pinned": false,
						"conditional_paths": [],
						"frozen": false,
						"outputs": [
							{
								"types": [
									"Data"
								],
								"selected": "Data",
								"name": "api_run_model",
								"display_name": "Data",
								"method": "run_model",
								"value": "__UNDEFINED__",
								"cache": true,
								"required_inputs": [
									"api_key",
									"gl",
									"hl",
									"num_results",
									"query"
								]
							},
							{
								"types": [
									"Tool"
								],
								"selected": "Tool",
								"name": "api_build_tool",
								"display_name": "Tool",
								"method": "build_tool",
								"value": "__UNDEFINED__",
								"cache": true,
								"required_inputs": [
									"api_key",
									"gl",
									"hl",
									"num_results",
									"query"
								]
							}
						],
						"field_order": [
							"api_key",
							"query",
							"num_results",
							"gl",
							"hl"
						],
						"beta": false,
						"edited": true,
						"metadata": {},
						"lf_version": "1.0.19"
					},
					"id": "NewsAPI-gygRV"
				},
				"selected": false,
				"width": 384,
				"height": 692,
				"positionAbsolute": {
					"x": -1829.8812507747835,
					"y": 1528.9340590628806
				},
				"dragging": false
			},
			{
				"id": "NewsAPI-oeHfa",
				"type": "genericNode",
				"position": {
					"x": 194.3197337881403,
					"y": 1518.6283801638784
				},
				"data": {
					"type": "YahooFinanceCrypto",
					"node": {
						"template": {
							"_type": "Component",
							"code": {
								"type": "code",
								"required": true,
								"placeholder": "",
								"list": false,
								"show": true,
								"multiline": true,
								"value": "from typing import Any\r\n\r\nfrom langchain.tools import StructuredTool\r\nfrom pydantic import BaseModel, Field\r\nfrom langflow.base.langchain_utilities.model import LCToolComponent\r\nfrom langflow.field_typing import Tool\r\nfrom langflow.inputs import MessageTextInput, SecretStrInput\r\nfrom langflow.schema import Data\r\nimport yfinance as yf\r\n\r\n\r\n# Define the component class for Yahoo Finance Crypto API\r\nclass YahooFinanceCryptoComponent(LCToolComponent):\r\n    display_name: str = \"Yahoo Finance Crypto\"\r\n    description: str = \"Retrieve cryptocurrency and blockchain-related data using Yahoo Finance.\"\r\n    name = \"YahooFinanceCrypto\"\r\n    documentation: str = \"https://www.yahoofinanceapi.com/\"\r\n\r\n    # Define the inputs needed for this component\r\n    inputs = [\r\n        MessageTextInput(name=\"crypto_symbol\", display_name=\"Cryptocurrency Symbol\", required=True),\r\n        MessageTextInput(name=\"metric\", display_name=\"Financial Metric\", required=False, value=\"summary\"),\r\n    ]\r\n\r\n    # Define the schema for the API tool arguments\r\n    class YahooFinanceCryptoSchema(BaseModel):\r\n        crypto_symbol: str = Field(..., description=\"The cryptocurrency symbol (e.g., BTC-USD for Bitcoin).\")\r\n        metric: str = Field(\"summary\", description=\"The financial metric to retrieve (e.g., 'summary', 'price').\")\r\n\r\n    # Define the API Wrapper for Yahoo Finance\r\n    class YahooFinanceCryptoWrapper:\r\n        def __init__(self, crypto_symbol: str, metric: str = \"summary\"):\r\n            self.crypto_symbol = crypto_symbol\r\n            self.metric = metric\r\n            self.ticker = yf.Ticker(crypto_symbol)  # Initialize with the cryptocurrency symbol\r\n\r\n        def get_crypto_data(self) -> dict[str, Any]:\r\n            # Based on the metric, retrieve the corresponding financial data\r\n            if self.metric == \"summary\":\r\n                return self.ticker.info  # Fetch general summary info\r\n            elif self.metric == \"price\":\r\n                return {\"price\": self.ticker.history(period=\"1d\")[\"Close\"].iloc[-1]}\r\n            elif self.metric == \"history\":\r\n                return self.ticker.history(period=\"1mo\")  # Fetch price history\r\n            else:\r\n                raise ValueError(\"Invalid metric. Please choose 'summary', 'price', or 'history'.\")\r\n\r\n    # Build the API wrapper\r\n    def _build_wrapper(self, crypto_symbol: str, metric: str):\r\n        return self.YahooFinanceCryptoWrapper(crypto_symbol=crypto_symbol, metric=metric)\r\n\r\n    # Tool builder function\r\n    def build_tool(self) -> Tool:\r\n        def get_crypto_data(crypto_symbol: str, metric: str = \"summary\") -> dict[str, Any]:\r\n            wrapper = self._build_wrapper(crypto_symbol=crypto_symbol, metric=metric)\r\n            return wrapper.get_crypto_data()\r\n\r\n        tool = StructuredTool.from_function(\r\n            name=\"yahoo_finance_crypto\",\r\n            description=\"Fetch cryptocurrency data using Yahoo Finance.\",\r\n            func=get_crypto_data,\r\n            args_schema=self.YahooFinanceCryptoSchema,\r\n        )\r\n\r\n        self.status = \"Yahoo Finance Crypto Tool created successfully.\"\r\n        return tool\r\n\r\n    # Run model function to trigger the API call\r\n    def run_model(self) -> list[Data]:\r\n        tool = self.build_tool()\r\n        # Retrieve and pass all necessary inputs\r\n        results = tool.run(\r\n            {\r\n                \"crypto_symbol\": self.crypto_symbol,\r\n                \"metric\": self.metric,\r\n            }\r\n        )\r\n\r\n        # Format the results for output\r\n        if self.metric == \"summary\":\r\n            formatted_results = [Data(data=results, text=f\"Summary: {results}\")]\r\n        elif self.metric == \"price\":\r\n            formatted_results = [Data(data=results, text=f\"Latest Price: {results['price']}\")]\r\n        elif self.metric == \"history\":\r\n            formatted_results = [\r\n                Data(data=results, text=f\"Price History: {results[['Close']].to_dict(orient='list')}\")\r\n            ]\r\n        else:\r\n            formatted_results = [Data(data=results, text=\"No valid data found.\")]\r\n\r\n        self.status = formatted_results\r\n        return formatted_results\r\n",
								"fileTypes": [],
								"file_path": "",
								"password": false,
								"name": "code",
								"advanced": true,
								"dynamic": true,
								"info": "",
								"load_from_db": false,
								"title_case": false
							},
							"crypto_symbol": {
								"trace_as_input": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": true,
								"placeholder": "",
								"show": true,
								"name": "crypto_symbol",
								"value": "BTC",
								"display_name": "Cryptocurrency Symbol",
								"advanced": false,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "str",
								"_input_type": "MessageTextInput"
							},
							"metric": {
								"trace_as_input": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "metric",
								"value": "summary",
								"display_name": "Financial Metric",
								"advanced": false,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "str",
								"_input_type": "MessageTextInput"
							}
						},
						"description": "Retrieve cryptocurrency and blockchain-related data using Yahoo Finance.",
						"base_classes": [
							"Data",
							"Tool"
						],
						"display_name": "Yahoo Finance Crypto API",
						"documentation": "https://www.yahoofinanceapi.com/",
						"custom_fields": {},
						"output_types": [],
						"pinned": false,
						"conditional_paths": [],
						"frozen": false,
						"outputs": [
							{
								"types": [
									"Data"
								],
								"selected": "Data",
								"name": "api_run_model",
								"display_name": "Data",
								"method": "run_model",
								"value": "__UNDEFINED__",
								"cache": true,
								"required_inputs": [
									"crypto_symbol",
									"metric"
								],
								"hidden": true
							},
							{
								"types": [
									"Tool"
								],
								"selected": "Tool",
								"name": "api_build_tool",
								"display_name": "Tool",
								"method": "build_tool",
								"value": "__UNDEFINED__",
								"cache": true,
								"required_inputs": [
									"crypto_symbol",
									"metric"
								]
							}
						],
						"field_order": [
							"crypto_symbol",
							"metric"
						],
						"beta": false,
						"edited": true,
						"metadata": {},
						"lf_version": "1.0.19"
					},
					"id": "NewsAPI-oeHfa"
				},
				"selected": false,
				"width": 384,
				"height": 393,
				"positionAbsolute": {
					"x": 194.3197337881403,
					"y": 1518.6283801638784
				},
				"dragging": false
			},
			{
				"id": "TextOutput-OMBx4",
				"type": "genericNode",
				"position": {
					"x": 1968.6611309972209,
					"y": -126.57971974843902
				},
				"data": {
					"type": "TextOutput",
					"node": {
						"template": {
							"_type": "Component",
							"code": {
								"type": "code",
								"required": true,
								"placeholder": "",
								"list": false,
								"show": true,
								"multiline": true,
								"value": "from langflow.base.io.text import TextComponent\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema.message import Message\n\n\nclass TextOutputComponent(TextComponent):\n    display_name = \"Text Output\"\n    description = \"Display a text output in the Playground.\"\n    icon = \"type\"\n    name = \"TextOutput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Text to be passed as output.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Text\", name=\"text\", method=\"text_response\"),\n    ]\n\n    def text_response(self) -> Message:\n        message = Message(\n            text=self.input_value,\n        )\n        self.status = self.input_value\n        return message\n",
								"fileTypes": [],
								"file_path": "",
								"password": false,
								"name": "code",
								"advanced": true,
								"dynamic": true,
								"info": "",
								"load_from_db": false,
								"title_case": false
							},
							"input_value": {
								"trace_as_input": true,
								"multiline": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "input_value",
								"value": "",
								"display_name": "Text",
								"advanced": false,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "Text to be passed as output.",
								"title_case": false,
								"type": "str",
								"_input_type": "MultilineInput"
							}
						},
						"description": "Display a text output in the Playground.",
						"icon": "type",
						"base_classes": [
							"Message"
						],
						"display_name": "Text Output",
						"documentation": "",
						"custom_fields": {},
						"output_types": [],
						"pinned": false,
						"conditional_paths": [],
						"frozen": false,
						"outputs": [
							{
								"types": [
									"Message"
								],
								"selected": "Message",
								"name": "text",
								"display_name": "Text",
								"method": "text_response",
								"value": "__UNDEFINED__",
								"cache": true
							}
						],
						"field_order": [
							"input_value"
						],
						"beta": false,
						"edited": false,
						"metadata": {},
						"lf_version": "1.0.19"
					},
					"id": "TextOutput-OMBx4"
				},
				"selected": false,
				"width": 384,
				"height": 290,
				"positionAbsolute": {
					"x": 1968.6611309972209,
					"y": -126.57971974843902
				},
				"dragging": false
			},
			{
				"id": "OpenAIModel-ocS2c",
				"type": "genericNode",
				"position": {
					"x": 726.2158720924689,
					"y": 681.242789878811
				},
				"data": {
					"type": "OpenAIModel",
					"node": {
						"template": {
							"_type": "Component",
							"output_parser": {
								"trace_as_metadata": true,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "output_parser",
								"value": "",
								"display_name": "Output Parser",
								"advanced": true,
								"input_types": [
									"OutputParser"
								],
								"dynamic": false,
								"info": "The parser to use to parse the output of the model",
								"title_case": false,
								"type": "other",
								"_input_type": "HandleInput"
							},
							"api_key": {
								"load_from_db": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "api_key",
								"value": "",
								"display_name": "OpenAI API Key",
								"advanced": false,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "The OpenAI API Key to use for the OpenAI model.",
								"title_case": false,
								"password": true,
								"type": "str",
								"_input_type": "SecretStrInput"
							},
							"code": {
								"type": "code",
								"required": true,
								"placeholder": "",
								"list": false,
								"show": true,
								"multiline": true,
								"value": "import operator\nfrom functools import reduce\n\nfrom langchain_openai import ChatOpenAI\nfrom pydantic.v1 import SecretStr\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.base.models.openai_constants import OPENAI_MODEL_NAMES\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs import BoolInput, DictInput, DropdownInput, FloatInput, IntInput, SecretStrInput, StrInput\nfrom langflow.inputs.inputs import HandleInput\n\n\nclass OpenAIModelComponent(LCModelComponent):\n    display_name = \"OpenAI\"\n    description = \"Generates text using OpenAI LLMs.\"\n    icon = \"OpenAI\"\n    name = \"OpenAIModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Tokens\",\n            advanced=True,\n            info=\"The maximum number of tokens to generate. Set to 0 for unlimited tokens.\",\n            range_spec=RangeSpec(min=0, max=128000),\n        ),\n        DictInput(name=\"model_kwargs\", display_name=\"Model Kwargs\", advanced=True),\n        BoolInput(\n            name=\"json_mode\",\n            display_name=\"JSON Mode\",\n            advanced=True,\n            info=\"If True, it will output JSON regardless of passing a schema.\",\n        ),\n        DictInput(\n            name=\"output_schema\",\n            is_list=True,\n            display_name=\"Schema\",\n            advanced=True,\n            info=\"The schema for the Output of the model. \"\n            \"You must pass the word JSON in the prompt. \"\n            \"If left blank, JSON mode will be disabled. [DEPRECATED]\",\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            advanced=False,\n            options=OPENAI_MODEL_NAMES,\n            value=OPENAI_MODEL_NAMES[0],\n        ),\n        StrInput(\n            name=\"openai_api_base\",\n            display_name=\"OpenAI API Base\",\n            advanced=True,\n            info=\"The base URL of the OpenAI API. \"\n            \"Defaults to https://api.openai.com/v1. \"\n            \"You can change this to use other APIs like JinaChat, LocalAI and Prem.\",\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"OpenAI API Key\",\n            info=\"The OpenAI API Key to use for the OpenAI model.\",\n            advanced=False,\n            value=\"OPENAI_API_KEY\",\n        ),\n        FloatInput(name=\"temperature\", display_name=\"Temperature\", value=0.1),\n        IntInput(\n            name=\"seed\",\n            display_name=\"Seed\",\n            info=\"The seed controls the reproducibility of the job.\",\n            advanced=True,\n            value=1,\n        ),\n        HandleInput(\n            name=\"output_parser\",\n            display_name=\"Output Parser\",\n            info=\"The parser to use to parse the output of the model\",\n            advanced=True,\n            input_types=[\"OutputParser\"],\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        # self.output_schema is a list of dictionaries\n        # let's convert it to a dictionary\n        output_schema_dict: dict[str, str] = reduce(operator.ior, self.output_schema or {}, {})\n        openai_api_key = self.api_key\n        temperature = self.temperature\n        model_name: str = self.model_name\n        max_tokens = self.max_tokens\n        model_kwargs = self.model_kwargs or {}\n        openai_api_base = self.openai_api_base or \"https://api.openai.com/v1\"\n        json_mode = bool(output_schema_dict) or self.json_mode\n        seed = self.seed\n\n        api_key = SecretStr(openai_api_key) if openai_api_key else None\n        output = ChatOpenAI(\n            max_tokens=max_tokens or None,\n            model_kwargs=model_kwargs,\n            model=model_name,\n            base_url=openai_api_base,\n            api_key=api_key,\n            temperature=temperature if temperature is not None else 0.1,\n            seed=seed,\n        )\n        if json_mode:\n            if output_schema_dict:\n                output = output.with_structured_output(schema=output_schema_dict, method=\"json_mode\")\n            else:\n                output = output.bind(response_format={\"type\": \"json_object\"})\n\n        return output\n\n    def _get_exception_message(self, e: Exception):\n        \"\"\"Get a message from an OpenAI exception.\n\n        Args:\n            e (Exception): The exception to get the message from.\n\n        Returns:\n            str: The message from the exception.\n        \"\"\"\n        try:\n            from openai import BadRequestError\n        except ImportError:\n            return None\n        if isinstance(e, BadRequestError):\n            message = e.body.get(\"message\")\n            if message:\n                return message\n        return None\n",
								"fileTypes": [],
								"file_path": "",
								"password": false,
								"name": "code",
								"advanced": true,
								"dynamic": true,
								"info": "",
								"load_from_db": false,
								"title_case": false
							},
							"input_value": {
								"trace_as_input": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "input_value",
								"value": "",
								"display_name": "Input",
								"advanced": false,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "str",
								"_input_type": "MessageInput"
							},
							"json_mode": {
								"trace_as_metadata": true,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "json_mode",
								"value": false,
								"display_name": "JSON Mode",
								"advanced": true,
								"dynamic": false,
								"info": "If True, it will output JSON regardless of passing a schema.",
								"title_case": false,
								"type": "bool",
								"_input_type": "BoolInput"
							},
							"max_tokens": {
								"trace_as_metadata": true,
								"range_spec": {
									"step_type": "float",
									"min": 0,
									"max": 128000,
									"step": 0.1
								},
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "max_tokens",
								"value": "",
								"display_name": "Max Tokens",
								"advanced": true,
								"dynamic": false,
								"info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
								"title_case": false,
								"type": "int",
								"_input_type": "IntInput"
							},
							"model_kwargs": {
								"trace_as_input": true,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "model_kwargs",
								"value": {},
								"display_name": "Model Kwargs",
								"advanced": true,
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "dict",
								"_input_type": "DictInput"
							},
							"model_name": {
								"trace_as_metadata": true,
								"options": [
									"gpt-4o-mini",
									"gpt-4o",
									"gpt-4-turbo",
									"gpt-4-turbo-preview",
									"gpt-4",
									"gpt-3.5-turbo",
									"gpt-3.5-turbo-0125"
								],
								"combobox": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "model_name",
								"value": "gpt-3.5-turbo",
								"display_name": "Model Name",
								"advanced": false,
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "str",
								"_input_type": "DropdownInput"
							},
							"openai_api_base": {
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "openai_api_base",
								"value": "",
								"display_name": "OpenAI API Base",
								"advanced": true,
								"dynamic": false,
								"info": "The base URL of the OpenAI API. Defaults to https://api.openai.com/v1. You can change this to use other APIs like JinaChat, LocalAI and Prem.",
								"title_case": false,
								"type": "str",
								"_input_type": "StrInput"
							},
							"output_schema": {
								"trace_as_input": true,
								"list": true,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "output_schema",
								"value": {},
								"display_name": "Schema",
								"advanced": true,
								"dynamic": false,
								"info": "The schema for the Output of the model. You must pass the word JSON in the prompt. If left blank, JSON mode will be disabled. [DEPRECATED]",
								"title_case": false,
								"type": "dict",
								"_input_type": "DictInput"
							},
							"seed": {
								"trace_as_metadata": true,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "seed",
								"value": 1,
								"display_name": "Seed",
								"advanced": true,
								"dynamic": false,
								"info": "The seed controls the reproducibility of the job.",
								"title_case": false,
								"type": "int",
								"_input_type": "IntInput"
							},
							"stream": {
								"trace_as_metadata": true,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "stream",
								"value": false,
								"display_name": "Stream",
								"advanced": true,
								"dynamic": false,
								"info": "Stream the response from the model. Streaming works only in Chat.",
								"title_case": false,
								"type": "bool",
								"_input_type": "BoolInput"
							},
							"system_message": {
								"trace_as_input": true,
								"trace_as_metadata": true,
								"load_from_db": false,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "system_message",
								"value": "",
								"display_name": "System Message",
								"advanced": true,
								"input_types": [
									"Message"
								],
								"dynamic": false,
								"info": "System message to pass to the model.",
								"title_case": false,
								"type": "str",
								"_input_type": "MessageTextInput"
							},
							"temperature": {
								"trace_as_metadata": true,
								"list": false,
								"required": false,
								"placeholder": "",
								"show": true,
								"name": "temperature",
								"value": 0.1,
								"display_name": "Temperature",
								"advanced": false,
								"dynamic": false,
								"info": "",
								"title_case": false,
								"type": "float",
								"_input_type": "FloatInput"
							}
						},
						"description": "Generates text using OpenAI LLMs.",
						"icon": "OpenAI",
						"base_classes": [
							"LanguageModel",
							"Message"
						],
						"display_name": "OpenAI",
						"documentation": "",
						"custom_fields": {},
						"output_types": [],
						"pinned": false,
						"conditional_paths": [],
						"frozen": false,
						"outputs": [
							{
								"types": [
									"Message"
								],
								"selected": "Message",
								"name": "text_output",
								"display_name": "Text",
								"method": "text_response",
								"value": "__UNDEFINED__",
								"cache": true,
								"required_inputs": [
									"input_value",
									"stream",
									"system_message"
								]
							},
							{
								"types": [
									"LanguageModel"
								],
								"selected": "LanguageModel",
								"name": "model_output",
								"display_name": "Language Model",
								"method": "build_model",
								"value": "__UNDEFINED__",
								"cache": true,
								"required_inputs": [
									"api_key",
									"json_mode",
									"max_tokens",
									"model_kwargs",
									"model_name",
									"openai_api_base",
									"output_schema",
									"seed",
									"temperature"
								]
							}
						],
						"field_order": [
							"input_value",
							"system_message",
							"stream",
							"max_tokens",
							"model_kwargs",
							"json_mode",
							"output_schema",
							"model_name",
							"openai_api_base",
							"api_key",
							"temperature",
							"seed",
							"output_parser"
						],
						"beta": false,
						"edited": false,
						"metadata": {},
						"lf_version": "1.0.19"
					},
					"id": "OpenAIModel-ocS2c"
				},
				"selected": false,
				"width": 384,
				"height": 589
			}
		],
		"edges": [
			{
				"source": "Prompt-G0PMC",
				"sourceHandle": "{dataType:Prompt,id:Prompt-G0PMC,name:prompt,output_types:[Message]}",
				"target": "ToolCallingAgent-tcOHY",
				"targetHandle": "{fieldName:input_value,id:ToolCallingAgent-tcOHY,inputTypes:[Message],type:str}",
				"data": {
					"targetHandle": {
						"fieldName": "input_value",
						"id": "ToolCallingAgent-tcOHY",
						"inputTypes": [
							"Message"
						],
						"type": "str"
					},
					"sourceHandle": {
						"dataType": "Prompt",
						"id": "Prompt-G0PMC",
						"name": "prompt",
						"output_types": [
							"Message"
						]
					}
				},
				"id": "reactflow__edge-Prompt-G0PMC{dataType:Prompt,id:Prompt-G0PMC,name:prompt,output_types:[Message]}-ToolCallingAgent-tcOHY{fieldName:input_value,id:ToolCallingAgent-tcOHY,inputTypes:[Message],type:str}",
				"animated": false,
				"className": ""
			},
			{
				"source": "ToolCallingAgent-tcOHY",
				"sourceHandle": "{dataType:ToolCallingAgent,id:ToolCallingAgent-tcOHY,name:response,output_types:[Message]}",
				"target": "ChatOutput-y8tZy",
				"targetHandle": "{fieldName:input_value,id:ChatOutput-y8tZy,inputTypes:[Message],type:str}",
				"data": {
					"targetHandle": {
						"fieldName": "input_value",
						"id": "ChatOutput-y8tZy",
						"inputTypes": [
							"Message"
						],
						"type": "str"
					},
					"sourceHandle": {
						"dataType": "ToolCallingAgent",
						"id": "ToolCallingAgent-tcOHY",
						"name": "response",
						"output_types": [
							"Message"
						]
					}
				},
				"id": "reactflow__edge-ToolCallingAgent-tcOHY{dataType:ToolCallingAgent,id:ToolCallingAgent-tcOHY,name:response,output_types:[Message]}-ChatOutput-y8tZy{fieldName:input_value,id:ChatOutput-y8tZy,inputTypes:[Message],type:str}",
				"animated": false,
				"className": ""
			},
			{
				"source": "Memory-9bSSe",
				"sourceHandle": "{dataType:Memory,id:Memory-9bSSe,name:messages_text,output_types:[Message]}",
				"target": "Prompt-G0PMC",
				"targetHandle": "{fieldName:conversation_history,id:Prompt-G0PMC,inputTypes:[Message,Text],type:str}",
				"data": {
					"targetHandle": {
						"fieldName": "conversation_history",
						"id": "Prompt-G0PMC",
						"inputTypes": [
							"Message",
							"Text"
						],
						"type": "str"
					},
					"sourceHandle": {
						"dataType": "Memory",
						"id": "Memory-9bSSe",
						"name": "messages_text",
						"output_types": [
							"Message"
						]
					}
				},
				"id": "reactflow__edge-Memory-9bSSe{dataType:Memory,id:Memory-9bSSe,name:messages_text,output_types:[Message]}-Prompt-G0PMC{fieldName:conversation_history,id:Prompt-G0PMC,inputTypes:[Message,Text],type:str}",
				"animated": false,
				"className": ""
			},
			{
				"source": "ChatInput-H5nXu",
				"sourceHandle": "{dataType:ChatInput,id:ChatInput-H5nXu,name:message,output_types:[Message]}",
				"target": "Prompt-G0PMC",
				"targetHandle": "{fieldName:input,id:Prompt-G0PMC,inputTypes:[Message,Text],type:str}",
				"data": {
					"targetHandle": {
						"fieldName": "input",
						"id": "Prompt-G0PMC",
						"inputTypes": [
							"Message",
							"Text"
						],
						"type": "str"
					},
					"sourceHandle": {
						"dataType": "ChatInput",
						"id": "ChatInput-H5nXu",
						"name": "message",
						"output_types": [
							"Message"
						]
					}
				},
				"id": "reactflow__edge-ChatInput-H5nXu{dataType:ChatInput,id:ChatInput-H5nXu,name:message,output_types:[Message]}-Prompt-G0PMC{fieldName:input,id:Prompt-G0PMC,inputTypes:[Message,Text],type:str}",
				"animated": false,
				"className": ""
			},
			{
				"source": "NewsAPI-gygRV",
				"sourceHandle": "{dataType:GoogleSerpAPI,id:NewsAPI-gygRV,name:api_build_tool,output_types:[Tool]}",
				"target": "ToolCallingAgent-tcOHY",
				"targetHandle": "{fieldName:tools,id:ToolCallingAgent-tcOHY,inputTypes:[Tool,BaseTool,StructuredTool],type:other}",
				"data": {
					"targetHandle": {
						"fieldName": "tools",
						"id": "ToolCallingAgent-tcOHY",
						"inputTypes": [
							"Tool",
							"BaseTool",
							"StructuredTool"
						],
						"type": "other"
					},
					"sourceHandle": {
						"dataType": "GoogleSerpAPI",
						"id": "NewsAPI-gygRV",
						"name": "api_build_tool",
						"output_types": [
							"Tool"
						]
					}
				},
				"id": "reactflow__edge-NewsAPI-gygRV{dataType:GoogleSerpAPI,id:NewsAPI-gygRV,name:api_build_tool,output_types:[Tool]}-ToolCallingAgent-tcOHY{fieldName:tools,id:ToolCallingAgent-tcOHY,inputTypes:[Tool,BaseTool,StructuredTool],type:other}",
				"animated": false,
				"className": ""
			},
			{
				"source": "ToolCallingAgent-tcOHY",
				"sourceHandle": "{dataType:ToolCallingAgent,id:ToolCallingAgent-tcOHY,name:response,output_types:[Message]}",
				"target": "TextOutput-OMBx4",
				"targetHandle": "{fieldName:input_value,id:TextOutput-OMBx4,inputTypes:[Message],type:str}",
				"data": {
					"targetHandle": {
						"fieldName": "input_value",
						"id": "TextOutput-OMBx4",
						"inputTypes": [
							"Message"
						],
						"type": "str"
					},
					"sourceHandle": {
						"dataType": "ToolCallingAgent",
						"id": "ToolCallingAgent-tcOHY",
						"name": "response",
						"output_types": [
							"Message"
						]
					}
				},
				"id": "reactflow__edge-ToolCallingAgent-tcOHY{dataType:ToolCallingAgent,id:ToolCallingAgent-tcOHY,name:response,output_types:[Message]}-TextOutput-OMBx4{fieldName:input_value,id:TextOutput-OMBx4,inputTypes:[Message],type:str}",
				"animated": false,
				"className": ""
			},
			{
				"source": "OpenAIModel-ocS2c",
				"sourceHandle": "{dataType:OpenAIModel,id:OpenAIModel-ocS2c,name:model_output,output_types:[LanguageModel]}",
				"target": "ToolCallingAgent-tcOHY",
				"targetHandle": "{fieldName:llm,id:ToolCallingAgent-tcOHY,inputTypes:[LanguageModel],type:other}",
				"data": {
					"targetHandle": {
						"fieldName": "llm",
						"id": "ToolCallingAgent-tcOHY",
						"inputTypes": [
							"LanguageModel"
						],
						"type": "other"
					},
					"sourceHandle": {
						"dataType": "OpenAIModel",
						"id": "OpenAIModel-ocS2c",
						"name": "model_output",
						"output_types": [
							"LanguageModel"
						]
					}
				},
				"id": "reactflow__edge-OpenAIModel-ocS2c{dataType:OpenAIModel,id:OpenAIModel-ocS2c,name:model_output,output_types:[LanguageModel]}-ToolCallingAgent-tcOHY{fieldName:llm,id:ToolCallingAgent-tcOHY,inputTypes:[LanguageModel],type:other}",
				"animated": false,
				"className": ""
			},
			{
				"source": "WikipediaAPI-chfQ8",
				"sourceHandle": "{dataType:WikipediaAPI,id:WikipediaAPI-chfQ8,name:api_build_tool,output_types:[Tool]}",
				"target": "ToolCallingAgent-tcOHY",
				"targetHandle": "{fieldName:tools,id:ToolCallingAgent-tcOHY,inputTypes:[Tool,BaseTool,StructuredTool],type:other}",
				"data": {
					"targetHandle": {
						"fieldName": "tools",
						"id": "ToolCallingAgent-tcOHY",
						"inputTypes": [
							"Tool",
							"BaseTool",
							"StructuredTool"
						],
						"type": "other"
					},
					"sourceHandle": {
						"dataType": "WikipediaAPI",
						"id": "WikipediaAPI-chfQ8",
						"name": "api_build_tool",
						"output_types": [
							"Tool"
						]
					}
				},
				"id": "reactflow__edge-WikipediaAPI-chfQ8{dataType:WikipediaAPI,id:WikipediaAPI-chfQ8,name:api_build_tool,output_types:[Tool]}-ToolCallingAgent-tcOHY{fieldName:tools,id:ToolCallingAgent-tcOHY,inputTypes:[Tool,BaseTool,StructuredTool],type:other}",
				"animated": false,
				"className": ""
			},
			{
				"source": "DuckDuckGoSearch-5zWhQ",
				"sourceHandle": "{dataType:DuckDuckGoSearch,id:DuckDuckGoSearch-5zWhQ,name:api_build_tool,output_types:[Tool]}",
				"target": "ToolCallingAgent-tcOHY",
				"targetHandle": "{fieldName:tools,id:ToolCallingAgent-tcOHY,inputTypes:[Tool,BaseTool,StructuredTool],type:other}",
				"data": {
					"targetHandle": {
						"fieldName": "tools",
						"id": "ToolCallingAgent-tcOHY",
						"inputTypes": [
							"Tool",
							"BaseTool",
							"StructuredTool"
						],
						"type": "other"
					},
					"sourceHandle": {
						"dataType": "DuckDuckGoSearch",
						"id": "DuckDuckGoSearch-5zWhQ",
						"name": "api_build_tool",
						"output_types": [
							"Tool"
						]
					}
				},
				"id": "reactflow__edge-DuckDuckGoSearch-5zWhQ{dataType:DuckDuckGoSearch,id:DuckDuckGoSearch-5zWhQ,name:api_build_tool,output_types:[Tool]}-ToolCallingAgent-tcOHY{fieldName:tools,id:ToolCallingAgent-tcOHY,inputTypes:[Tool,BaseTool,StructuredTool],type:other}",
				"animated": false,
				"className": ""
			},
			{
				"source": "CoinMarketCapAPI-6u9M0",
				"sourceHandle": "{dataType:NewsAPI,id:CoinMarketCapAPI-6u9M0,name:api_build_tool,output_types:[Tool]}",
				"target": "ToolCallingAgent-tcOHY",
				"targetHandle": "{fieldName:tools,id:ToolCallingAgent-tcOHY,inputTypes:[Tool,BaseTool,StructuredTool],type:other}",
				"data": {
					"targetHandle": {
						"fieldName": "tools",
						"id": "ToolCallingAgent-tcOHY",
						"inputTypes": [
							"Tool",
							"BaseTool",
							"StructuredTool"
						],
						"type": "other"
					},
					"sourceHandle": {
						"dataType": "NewsAPI",
						"id": "CoinMarketCapAPI-6u9M0",
						"name": "api_build_tool",
						"output_types": [
							"Tool"
						]
					}
				},
				"id": "reactflow__edge-CoinMarketCapAPI-6u9M0{dataType:NewsAPI,id:CoinMarketCapAPI-6u9M0,name:api_build_tool,output_types:[Tool]}-ToolCallingAgent-tcOHY{fieldName:tools,id:ToolCallingAgent-tcOHY,inputTypes:[Tool,BaseTool,StructuredTool],type:other}",
				"animated": false,
				"className": ""
			},
			{
				"source": "WikipediaAPI-otxuG",
				"sourceHandle": "{dataType:CoinMarketCapAPI,id:WikipediaAPI-otxuG,name:api_build_tool,output_types:[Tool]}",
				"target": "ToolCallingAgent-tcOHY",
				"targetHandle": "{fieldName:tools,id:ToolCallingAgent-tcOHY,inputTypes:[Tool,BaseTool,StructuredTool],type:other}",
				"data": {
					"targetHandle": {
						"fieldName": "tools",
						"id": "ToolCallingAgent-tcOHY",
						"inputTypes": [
							"Tool",
							"BaseTool",
							"StructuredTool"
						],
						"type": "other"
					},
					"sourceHandle": {
						"dataType": "CoinMarketCapAPI",
						"id": "WikipediaAPI-otxuG",
						"name": "api_build_tool",
						"output_types": [
							"Tool"
						]
					}
				},
				"id": "reactflow__edge-WikipediaAPI-otxuG{dataType:CoinMarketCapAPI,id:WikipediaAPI-otxuG,name:api_build_tool,output_types:[Tool]}-ToolCallingAgent-tcOHY{fieldName:tools,id:ToolCallingAgent-tcOHY,inputTypes:[Tool,BaseTool,StructuredTool],type:other}",
				"animated": false,
				"className": ""
			},
			{
				"source": "NewsAPI-oeHfa",
				"sourceHandle": "{dataType:YahooFinanceCrypto,id:NewsAPI-oeHfa,name:api_build_tool,output_types:[Tool]}",
				"target": "ToolCallingAgent-tcOHY",
				"targetHandle": "{fieldName:tools,id:ToolCallingAgent-tcOHY,inputTypes:[Tool,BaseTool,StructuredTool],type:other}",
				"data": {
					"targetHandle": {
						"fieldName": "tools",
						"id": "ToolCallingAgent-tcOHY",
						"inputTypes": [
							"Tool",
							"BaseTool",
							"StructuredTool"
						],
						"type": "other"
					},
					"sourceHandle": {
						"dataType": "YahooFinanceCrypto",
						"id": "NewsAPI-oeHfa",
						"name": "api_build_tool",
						"output_types": [
							"Tool"
						]
					}
				},
				"id": "reactflow__edge-NewsAPI-oeHfa{dataType:YahooFinanceCrypto,id:NewsAPI-oeHfa,name:api_build_tool,output_types:[Tool]}-ToolCallingAgent-tcOHY{fieldName:tools,id:ToolCallingAgent-tcOHY,inputTypes:[Tool,BaseTool,StructuredTool],type:other}",
				"animated": false,
				"className": ""
			}
		],
		"viewport": {
			"x": 897.3570411711735,
			"y": -355.53317142495009,
			"zoom": 0.5877739494992408
		}
	},
	"description": "Engineered for Excellence, Built for Business.",
	"name": "smart_agent_with_tools",
	"last_tested_version": "1.0.19",
	"endpoint_name": null,
	"is_component": false
}